static char help[] = "Applies the 2023 preconditioner of Benzi and Faccio\n\n";

#include <petscmat.h>
#include <petscviewer.h>
#include <petscvec.h>
#include <petscis.h>
#include <petscksp.h>

#include <iostream>

/*
 * This example reproduces the preconditioner outlined in Benzi's paper
 * https://doi.org/10.1137/22M1505529. The problem considered is:
 *
 * (A + gamma UU^T)x = b
 *
 * whose structure arises from, for example, grad-div stabilization in the
 * Navier-Stokes momentum equation. In the code we will also refer to
 * gamma UU^T as J. The preconditioner developed by Benzi is:
 *
 * P_alpha = (A + alpha I)(alpha I + gamma UU^T)
 *
 * Another variant which may yield better convergence depending on the specific
 * problem is
 *
 * P_alpha = (A + alpha D) D^-1 (alpha D + gamma UU^T)
 *
 * where D = diag(A + gamma UU^T). This is the variant implemented
 * here. Application of the preconditioner involves (approximate) solution of
 * two systems, one with (A + alpha D), and another with (alpha D + gamma
 * UU^T). For small alpha (which generally yields the best overall
 * preconditioner), (alpha D + gamma UU^T) is ill-conditioned. To combat this we
 * solve (alpha D + gamma UU^T) using the Sherman-Morrison-Woodbury (SMW) matrix
 * identity, which effectively converts the grad-div structure to a much nicer
 * div-grad (laplacian) structure.
 *
 * The matrices used as input can be generated by running the matlab/octave
 * program IFISS. The particular matrices checked into the datafiles repository
 * and used in testing of this example correspond to a leaky lid-driven cavity
 * with a stretched grid and Q2-Q1 finite elements. The matrices are taken from
 * the last iteration of a Picard solve with tolerance 1e-8 with a viscosity of
 * 0.1 and a 32x32 grid. We summarize below iteration counts from running this
 * preconditioner for different grids and viscosity with a KSP tolerance of 1e-6.
 *
 *       32x32 64x64 128x128
 * 0.1   28    36    43
 * 0.01  59    75    73
 * 0.002 136   161   167
 *
 * A reader of Benzi's paper will note that the performance shown above with
 * respect to decreasing viscosity is significantly worse than in the
 * paper. This is actually because of the choice of RHS. In Benzi's work, the
 * RHS was generated by multiplying the operator with a vector of 1s whereas
 * here we generate the RHS using a random vector. The iteration counts from the
 * Benzi paper can be reproduced by changing the RHS generation in this example,
 * but we choose to use the more difficult RHS as the resulting performance may
 * more closely match what users experience in "physical" contexts.
 */

PetscErrorCode
CreateAndLoadMat(const char mat_name[], Mat * mat)
{
  PetscViewer viewer;

  PetscFunctionBeginUser;
  PetscCall(PetscViewerBinaryOpen(PETSC_COMM_WORLD, mat_name, FILE_MODE_READ, &viewer));
  PetscCall(MatCreate(PETSC_COMM_WORLD, mat));
  PetscCall(MatSetType(*mat, MATMPIAIJ));
  PetscCall(PetscObjectSetName((PetscObject)*mat, mat_name));
  PetscCall(MatSetFromOptions(*mat));
  PetscCall(MatLoad(*mat, viewer));
  PetscCall(PetscViewerDestroy(&viewer));
  PetscFunctionReturn(PETSC_SUCCESS);
}

PetscErrorCode
CreateAndLoadVec(const char vec_name[], Vec * vec)
{
  PetscViewer viewer;

  PetscFunctionBeginUser;
  PetscCall(PetscViewerBinaryOpen(PETSC_COMM_WORLD, vec_name, FILE_MODE_READ, &viewer));
  PetscCall(VecCreate(PETSC_COMM_WORLD, vec));
  PetscCall(PetscObjectSetName((PetscObject)*vec, vec_name));
  PetscCall(VecSetFromOptions(*vec));
  PetscCall(VecLoad(*vec, viewer));
  PetscCall(PetscViewerDestroy(&viewer));
  PetscFunctionReturn(PETSC_SUCCESS);
}

int
main(int argc, char ** args)
{
  Mat AplusJ, AplusD, JplusD, D;
  Vec x, bLower, bInner;
  KSP ksp;
  PC pc, pcA, pcJ;

  PetscFunctionBeginUser;
  PetscCall(PetscInitialize(&argc, &args, (char *)0, help));

  PetscCall(CreateAndLoadMat("AplusJ", &AplusJ));
  PetscCall(CreateAndLoadMat("AplusD", &AplusD));
  PetscCall(CreateAndLoadMat("JplusD", &JplusD));
  PetscCall(CreateAndLoadMat("D", &D));
  PetscCall(CreateAndLoadVec("bInner.vec", &bInner));
  PetscCall(CreateAndLoadVec("bLower.vec", &bLower));

  // Create x
  PetscCall(VecDuplicate(bLower, &x));

  // Set preconditioner operators
  PetscCall(KSPCreate(PETSC_COMM_WORLD, &ksp));
  PetscCall(KSPSetOperators(ksp, AplusJ, AplusJ));
  PetscCall(KSPSetNormType(ksp, KSP_NORM_UNPRECONDITIONED));
  PetscCall(KSPGMRESSetRestart(ksp, 300));
  PetscCall(KSPGetPC(ksp, &pc));
  PetscCall(PCSetType(pc, PCCOMPOSITE));
  PetscCall(PCCompositeSetType(pc, PC_COMPOSITE_SPECIAL));
  PetscCall(PCCompositeAddPCType(pc, PCILU));
  PetscCall(PCCompositeAddPCType(pc, PCCHOLESKY));
  PetscCall(PCCompositeGetPC(pc, 0, &pcA));
  PetscCall(PCCompositeGetPC(pc, 1, &pcJ));
  PetscCall(PCSetOperators(pcA, AplusD, AplusD));
  PetscCall(PCSetOperators(pcJ, JplusD, JplusD));
  PetscCall(PCCompositeSpecialSetAlphaMat(pc, D));

  // Solve
  PetscCall(KSPSetFromOptions(ksp));
  std::cout << "Performing A-block KSP solve for lower triangular factor" << std::endl;
  PetscCall(KSPSolve(ksp, bLower, x));
  std::cout << std::endl << "Performing A-block KSP solve for inner Schur solve" << std::endl;
  PetscCall(KSPSolve(ksp, bInner, x));

  PetscCall(MatDestroy(&AplusJ));
  PetscCall(MatDestroy(&AplusD));
  PetscCall(MatDestroy(&JplusD));
  PetscCall(VecDestroy(&x));
  PetscCall(VecDestroy(&bLower));
  PetscCall(VecDestroy(&bInner));
  PetscCall(KSPDestroy(&ksp));

  PetscCall(PetscFinalize());
  return 0;
}
